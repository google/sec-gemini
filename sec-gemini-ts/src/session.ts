/**
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import randomUUID from './uuid';
import HttpClient from './http';
import { StreamerConfig, Streamer } from './streamer';
import { generateSessionName } from './sessionNameGenerator'; // Import the name generator

// Manual enums (Ensure these are up-to-date)
import { EndPointsEnum, LogsEndPointsEnum, ResponseStatusEnum } from './enum';

// Import Autogenerated Enums and Types needed within the session class
import { RoleEnum, MessageTypeEnum, StateEnum, MimeTypeEnum, FeedbackTypeEnum } from './secgeminienums';

import {
  Attachment,
  SessionRequest,
  SessionResponse,
  OpResult,
  Message,
  Usage,
  PublicSessionInput,
  PublicSessionOutput,
  PublicUser,
  Feedback,
  MimeType, // String literal types
  FeedbackType,
  Role,
  State,
  ModelInfoInput,
  PublicSessionFile,
  DetachFileRequest,
} from './secgeminitypes';

// --- Constants ---
const MIN_TTL_SECONDS = 300;
const ROOT_MESSAGE_ID = '3713'; // Consider making this configurable or fetching if needed

// --- Helper Functions ---

/**
 * Isomorphic Base64 encoding for Uint8Array.
 * NOTE: This implementation uses browser APIs (`Blob`, `FileReader`).
 * For Node.js compatibility, replace with `Buffer.from(uint8array).toString('base64')`
 * or use an isomorphic library like 'buffer'.
 **/
async function uint8ArrayToBase64(uint8array: Uint8Array): Promise<string> {
  // Browser implementation
  if (typeof window !== 'undefined' && typeof Blob !== 'undefined' && typeof FileReader !== 'undefined') {
    return new Promise((resolve, reject) => {
      const blob = new Blob([uint8array]);
      const reader = new FileReader();
      reader.onload = (evt) => {
        const dataUrl = evt?.target?.result as string;
        if (!dataUrl) {
          reject(new Error('Failed to read blob as Data URL.'));
          return;
        }
        // Strip "data:*/*;base64," prefix
        const base64String = dataUrl.substring(dataUrl.indexOf(',') + 1);
        resolve(base64String);
      };
      reader.onerror = (evt) => {
        reject(evt.target?.error || new Error('FileReader error'));
      };
      reader.readAsDataURL(blob);
    });
  }
  // Node.js implementation (requires 'buffer' module, implicitly available)
  else if (typeof Buffer !== 'undefined') {
    return Promise.resolve(Buffer.from(uint8array).toString('base64'));
  } else {
    return Promise.reject(new Error('Cannot determine environment or unsupported (no Blob/FileReader or Buffer).'));
  }
}

// --- Session Class ---

// Alias for Streamer options
export interface StreamOptions {
  reconnect?: boolean;
  maxRetries?: number;
  delay?: number;
  // True if the backend should use streaming (e.g. SSE) to send the response.
  // If so, the response may include PARTIAL_CONTENT messages, which should
  // always be followed by a final aggregate message.
  stream?: boolean;
}

/**
 * Represents an interface that can be used to recreate an InteractiveSession.
 */
export interface InteractiveSessionData {
  user: PublicUser;
  httpUrl: string;
  logsHttpUrl: string; 
  websocketURL: string;
  apiKey: string;
  session: PublicSessionOutput;
  initialLogPreference: boolean;
}

/**
 * Represents an interactive SecGemini session.
 * Manages session state, communication (generation, streaming),
 * file attachments, and feedback.
 * Should be created via `SecGemini.createSession()` or `SecGemini.resumeSession()`.
 */
export class InteractiveSession {
  // Dependencies injected by SecGemini client
  private user: PublicUser;
  private http: HttpClient;
  private logsHttp: HttpClient;
  private websocketURL: string;
  private apiKey: string;

  // Session state - cached locally after register/resume
  // Use getters for safe external access
  private _session: PublicSessionOutput | null = null;

  // Initial logging preference (can be overridden by user settings/resumed session)
  private initialLogPreference: boolean;

  /**
   * @internal - Constructor is internal. Use SecGemini client methods.
   */
  constructor(
    user: PublicUser,
    httpClient: HttpClient,
    websocketURL: string,
    apiKey: string,
    logsHttpClient: HttpClient,
    logSessionPreference: boolean = true, // Initial preference
  ) {
    this.user = user;
    this.http = httpClient;
    this.logsHttp = logsHttpClient;
    this.websocketURL = websocketURL;
    this.apiKey = apiKey;
    this.initialLogPreference = logSessionPreference; // Store initial preference
  }

  /**
   * Given all relevant session data, this function creates an
   * InteractiveSession.
   */
  public static from(data: InteractiveSessionData): InteractiveSession {
    const httpClient = new HttpClient(data.httpUrl, data.apiKey);
    const logsHttp = new HttpClient(data.logsHttpUrl, data.apiKey);
    const interactiveSession = new InteractiveSession(
      data.user,
      httpClient,
      data.websocketURL,
      data.apiKey,
      logsHttp,
      data.initialLogPreference,
  
    );
    interactiveSession._session = data.session;
    return interactiveSession;
  }

  // --- Public Getters for Session State ---

  public get id(): string {
    if (!this._session?.id) {
      throw new Error('Session is not initialized or ID is missing.');
    }
    return this._session.id;
  }

  public get model(): ModelInfoInput {
    if (!this._session?.model) {
      throw new Error('Session is not initialized or model info is missing.');
    }
    return this._session.model;
  }

  public get ttl(): number {
    if (this._session?.ttl === undefined || this._session?.ttl === null) {
      throw new Error('Session is not initialized or TTL is missing.');
    }
    return this._session.ttl;
  }

  public get language(): string | undefined {
    if (!this._session) throw new Error('Session is not initialized.');
    return this._session.language;
  }

  public get turns(): number | undefined {
    if (!this._session) throw new Error('Session is not initialized.');
    return this._session.turns;
  }

  public get name(): string {
    if (!this._session?.name) {
      throw new Error('Session is not initialized or name is missing.');
    }
    return this._session.name;
  }

  public get description(): string {
    if (!this._session?.description) {
      throw new Error('Session is not initialized or description is missing.');
    }
    return this._session.description;
  }

  public get create_time(): number | undefined {
    if (!this._session) throw new Error('Session is not initialized.');
    return this._session.create_time;
  }

  public get update_time(): number | undefined {
    if (!this._session) throw new Error('Session is not initialized.');
    return this._session.update_time;
  }

  public get messages(): ReadonlyArray<Message> {
    // Return ReadonlyArray
    if (!this._session) throw new Error('Session is not initialized.');
    return this._session.messages ?? [];
  }

  public get usage(): Usage | undefined {
    if (!this._session) throw new Error('Session is not initialized.');
    return this._session.usage;
  }

  public get can_log(): boolean {
    // Reflects the actual logging status determined during register/resume
    if (this._session?.can_log === undefined || this._session?.can_log === null) {
      throw new Error('Session is not initialized or can_log status is missing.');
    }
    return this._session.can_log;
  }

  public get state(): State | undefined {
    if (!this._session) throw new Error('Session is not initialized.');
    return this._session.state;
  }

  public get files(): ReadonlyArray<PublicSessionFile> {
    // Return ReadonlyArray
    if (!this._session) throw new Error('Session is not initialized.');
    return this._session.files ?? [];
  }

  // --- Core Session Lifecycle & Interaction Methods ---

  /**
   * @internal - Registers the session with the backend. Called by `SecGemini.createSession()`.
   *
   * @param options - Registration parameters including the specific ModelInfoInput.
   * @throws Error on validation failure, API error, or registration failure.
   */
  public async register(options: {
    ttl: number;
    model: ModelInfoInput; // Now requires ModelInfoInput
    name?: string;
    description?: string;
    language?: string;
    id?: string; // Optional ID for creating named sessions.
  }): Promise<void> {
    const {
      ttl,
      model, // Destructure the required model object
      name = '',
      description = '',
      language = 'en',
      id = '', // Optional ID, can be empty for auto-generated
    } = options;

    // --- Validation ---
    if (ttl <= MIN_TTL_SECONDS) {
      throw new Error(`TTL must be greater than ${MIN_TTL_SECONDS} seconds.`);
    }
    if (!model || !model.model_string) {
      throw new Error('Valid ModelInfoInput object is required for registration.');
    }

    // Determine final logging status based on user preference and permissions
    let canLogFinal = this.initialLogPreference;
    if (this.user.never_log) {
      if (canLogFinal) {
        console.warn('User policy forces disabling session logging, overriding preference.'); // Use logger
        canLogFinal = false;
      }
    } else if (!this.user.can_disable_logging && !canLogFinal) {
      throw new Error('User is not authorized to disable session logging.');
    }

    // --- Prepare Payload ---
    const sessionId = id || randomUUID(); // Generate ID locally for the request
    const sessionName = name || generateSessionName(); // Use generator if no name provided

    const registerPayload: PublicSessionInput = {
      id: sessionId,
      user_id: this.user.id,
      org_id: this.user.org_id,
      model: model, // Use the provided ModelInfoInput object
      ttl: ttl,
      name: sessionName,
      description: description,
      can_log: canLogFinal,
      language: language,
      // state: StateEnum.START as State, // Default state if needed by API
    };

    // --- API Call ---
    let resp: OpResult;
    try {
      // Ensure EndPointsEnum.REGISTER_SESSION maps to '/v1/session/register'
      resp = await this.http.post<OpResult>(EndPointsEnum.REGISTER_SESSION, registerPayload);
    } catch (error: any) {
      console.error(`[Session][Register][HTTP]: Network or client error`, error);
      throw new Error(`Session registration failed due to network/HTTP error: ${error.message}`);
    }

    // --- Handle Response ---
    if (!resp || !resp.ok || resp.status_code !== ResponseStatusEnum.OK) {
      const errorMsg = `Session registration failed: ${resp?.status_message || 'Unknown API error'} (Status: ${resp?.status_code})`;
      console.error(`[Session][Register][API]: ${errorMsg}`);
      throw new Error(errorMsg);
    }

    console.info(`[Session][Register][API]: Session ${sessionId} (${sessionName}) registered successfully.`);

    // --- Update Local Cache ---
    // Create the PublicSessionOutput structure for the cache
    this._session = {
      id: sessionId,
      user_id: this.user.id,
      org_id: this.user.org_id,
      model: model, // Store the registered model info
      ttl: ttl,
      name: sessionName,
      description: description,
      can_log: canLogFinal, // Store the final logging status
      language: language,
      // Initialize other fields based on API design (some might be added by backend)
      messages: [],
      files: [],
      // state: StateEnum.START as State,
      // create_time, update_time, usage etc. will be populated by subsequent fetches
      // if the API doesn't return the full object on register.
    };
  }

  /**
   * @internal - Resumes an existing session. Called by `SecGemini.resumeSession()`.
   *
   * @param sessionId - The ID of the session to resume.
   * @returns `true` if successful (now throws error on failure).
   * @throws Error if the session cannot be fetched or found.
   */
  public async resume(sessionId: string): Promise<boolean> {
    // Keep bool return for compatibility? Or change to void? Change to void is cleaner.
    if (!sessionId) {
      throw new Error('Session ID is required to resume.');
    }

    const session = await this._fetchSessionById(sessionId); // Use internal fetcher

    // _fetchSessionById now throws if not found or on error
    this._session = session;

    console.info(`[Session][Resume]: Session ${this.id} (${this.name}) resumed successfully.`);
    return true; // Return true for now, although throwing on error is preferred.
  }

  /**
   * Sends a query to the session model for generation (non-streaming).
   *
   * @param prompt - The user's input prompt.
   * @returns A Promise resolving to the SessionResponse containing generated messages.
   * @throws Error if the session is not initialized, prompt is empty, or API call fails.
   */
  public async generate(prompt: string): Promise<SessionResponse> {
    this._ensureInitialized(); // Check if session exists

    if (!prompt) {
      throw new Error('Prompt cannot be empty for generate request.');
    }

    const message = this._buildPromptMessage(prompt);

    const req: SessionRequest = {
      id: this.id,
      messages: [message],
      // Model is implicitly defined by the session on the backend
    };

    let resp: SessionResponse;
    try {
      // Ensure EndPointsEnum.GENERATE maps to '/v1/session/generate'
      resp = await this.http.post<SessionResponse>(EndPointsEnum.GENERATE, req);
    } catch (error: any) {
      console.error(`[Session][Generate][HTTP]: Network or client error`, error);
      throw new Error(`Generation request failed due to network/HTTP error: ${error.message}`);
    }

    // Check response status embedded within SessionResponse
    if (resp.status_code !== ResponseStatusEnum.OK) {
      const errorMsg = `Generation failed: ${resp.status_message || 'Unknown API error'} (Status: ${resp.status_code})`;
      console.error(`[Session][Generate][API]: ${errorMsg}`);
      throw new Error(errorMsg);
    }

    // TODO: Consider updating this._session.messages cache with the response messages?
    // This requires careful merging/replacement logic. For now, just return.

    return resp;
  }

  /**
   * Initiates a streaming generation request.
   * Use `for await...of` to consume the stream of messages.
   *
   * @param query - The user's input query for streaming.
   * @returns An AsyncIterableIterator yielding Message objects.
   * @throws Error if the session is not initialized or the query is empty.
   */
  public streamer(
    onmessage: (message: Message) => void,
    onopen: (() => void) | null = null,
    onerror: ((error: Error) => void) | null = null,
    onclose: (() => void) | null = null,
    options: StreamOptions = {} // Options still not used here by default Streamer
  ): Streamer {
    this._ensureInitialized();
    // Note: Original Python code sends the initial query message via WebSocket.
    // The Streamer class needs to handle this initial message sending.
    // We might need to adjust Streamer.create or add a method to Streamer to send the initial message.

    // TODO: Adapt Streamer.create if necessary to send the initial query message.
    // const initialMessage = this._buildPromptMessage(query);
    // Pass initialMessage to Streamer or call a streamer.send() method.

    const config: StreamerConfig = {
      // TODO: set other field based on options.
      stream: options.stream,
    };
    return Streamer.create(
      onmessage,
      onopen,
      onerror,
      onclose,
      this.websocketURL, // Use the URL from SecGemini client
      this.id,
      this.apiKey,
      config
    );
  }

  /**
   * Updates session metadata (name, description, TTL).
   *
   * @param name - Optional new name for the session.
   * @param description - Optional new description for the session.
   * @param ttl - Optional new TTL in seconds (must be > 300).
   * @throws Error if the session is not initialized or the update fails.
   */
  public async update(name: string = '', description: string = '', ttl: number = 0): Promise<void> {
    this._ensureInitialized();

    const currentSession = this._session as PublicSessionOutput; // Type assertion after check

    // Prepare the PublicSessionInput payload - API requires full session-like object
    const updatePayload: PublicSessionInput = {
      // Required fields from current state
      id: currentSession.id,
      user_id: currentSession.user_id,
      org_id: currentSession.org_id,
      model: currentSession.model, // Must include current model
      // Apply updates
      name: name || currentSession.name,
      description: description || currentSession.description,
      ttl: currentSession.ttl, // Start with current
      // Other fields from PublicSessionInput possibly needed by API
      can_log: currentSession.can_log,
      language: currentSession.language,
      state: currentSession.state,
    };

    // Apply TTL update logic
    if (ttl > 0) {
      if (ttl <= MIN_TTL_SECONDS) {
        throw new Error(`TTL must be greater than ${MIN_TTL_SECONDS} seconds`);
      }
      updatePayload.ttl = ttl;
    }

    // --- API Call ---
    let resp: OpResult;
    try {
      // Ensure EndPointsEnum.UPDATE_SESSION maps to '/v1/session/update'
      resp = await this.http.post<OpResult>(EndPointsEnum.UPDATE_SESSION, updatePayload);
    } catch (error: any) {
      console.error(`[Session][Update][HTTP]: Network or client error`, error);
      throw new Error(`Session update failed due to network/HTTP error: ${error.message}`);
    }

    // --- Handle Response ---
    if (!resp || !resp.ok || resp.status_code !== ResponseStatusEnum.OK) {
      const errorMsg = `Session update failed: ${resp?.status_message || 'Unknown API error'} (Status: ${resp?.status_code})`;
      console.error(`[Session][Update][API]: ${errorMsg}`);
      throw new Error(errorMsg);
    }

    console.info(`[Session][Update][API]: Session ${this.id} updated successfully.`);

    // --- Update Local Cache ---
    // Update cache optimistically based on the request. Re-fetching would be safer.
    this._session = {
      ...currentSession, // Keep existing fields
      ...updatePayload, // Overwrite with updated fields from payload
      id: currentSession.id, // Ensure ID isn't accidentally overwritten if missing in payload
    };
  }

  /**
   * Deletes the current session from the backend.
   * This instance will become unusable after deletion.
   *
   * @throws Error if the session is not initialized or deletion fails.
   */
  public async delete(): Promise<void> {
    this._ensureInitialized();
    const currentSession = this._session as PublicSessionOutput; // Type assertion after check

    // API expects PublicSessionInput body for delete. Construct it.
    const deletePayload: PublicSessionInput = {
      id: currentSession.id,
      user_id: currentSession.user_id,
      org_id: currentSession.org_id,
      model: currentSession.model,
      ttl: currentSession.ttl,
      name: currentSession.name,
      description: currentSession.description,
      can_log: currentSession.can_log,
      language: currentSession.language,
      state: currentSession.state,
    };

    // --- API Call ---
    let resp: OpResult;
    try {
      // Ensure EndPointsEnum.DELETE_SESSION maps to '/v1/session/delete'
      resp = await this.http.post<OpResult>(EndPointsEnum.DELETE_SESSION, deletePayload);
    } catch (error: any) {
      console.error(`[Session][Delete][HTTP]: Network or client error`, error);
      throw new Error(`Session deletion failed due to network/HTTP error: ${error.message}`);
    }

    // --- Handle Response ---
    if (!resp || !resp.ok || resp.status_code !== ResponseStatusEnum.OK) {
      const errorMsg = `Session deletion failed: ${resp?.status_message || 'Unknown API error'} (Status: ${resp?.status_code})`;
      console.error(`[Session][Delete][API]: ${errorMsg}`);
      throw new Error(errorMsg);
    }

    console.info(`[Session][Delete][API]: Session ${this.id} deleted successfully.`);

    // Clear local state to prevent further use
    this._session = null;
  }

  // --- File Handling ---

  /**
   * Attaches a file (from memory) to the session.
   *
   * @param filename - The desired filename for the attachment.
   * @param content - The file content as a string or ArrayBuffer/Uint8Array.
   * @param mimeTypeHint - Hint for the MIME type of the file (may be ignored by the backend).
   * @throws Error if session not initialized, MIME type invalid, encoding fails, or API fails.
   */
  public async attachFile(
    filename: string,
    content: string | ArrayBuffer | Uint8Array,
    mimeTypeHint?: string
  ): Promise<PublicSessionFile> {
    this._ensureInitialized();

    let bytes: Uint8Array;
    if (typeof content === 'string') {
      bytes = new TextEncoder().encode(content);
    } else if (content instanceof ArrayBuffer) {
      bytes = new Uint8Array(content);
    } else if (content instanceof Uint8Array) {
      bytes = content;
    } else {
      throw new Error('Invalid content type for attachFile. Use string, ArrayBuffer, or Uint8Array.');
    }

    let encoded_content: string;
    try {
      encoded_content = await uint8ArrayToBase64(bytes);
    } catch (error: any) {
      console.error(`[Session][Attachment]: Base64 encoding failed`, error);
      throw new Error(`Failed to encode file content for attachment: ${error.message}`);
    }

    const attachment: Attachment = {
      session_id: this.id,
      filename: filename,
      mime_type: mimeTypeHint,
      content: encoded_content,
    };

    // --- API Call ---
    let resp: OpResult;
    try {
      // Ensure EndPointsEnum.ATTACH_FILE maps to '/v1/session/attach_file'
      resp = await this.http.post<OpResult>(EndPointsEnum.ATTACH_FILE, attachment);
    } catch (error: any) {
      console.error(`[Session][Attachment][HTTP]: Network or client error`, error);
      throw new Error(`Attaching file failed due to network/HTTP error: ${error.message}`);
    }

    // --- Handle Response ---
    if (!resp || !resp.ok || resp.data === undefined || resp.status_code !== ResponseStatusEnum.OK) {
      const errorMsg = `Attaching file failed: ${resp?.status_message || 'Unknown API error'} (Status: ${resp?.status_code})`;
      console.error(`[Session][Attachment][API]: ${errorMsg}`);
      throw new Error(errorMsg);
    }

    const publicSessionFile: PublicSessionFile = resp.data as PublicSessionFile;

    console.info(`[Session][Attachment][API]: File ${filename} attached to session ${this.id}.`);

    // Refreshing cached PublicSession
    await this.fetchSession();

    return publicSessionFile;
  }

  /**
   * Detaches a file from the session by its index.
   *
   * @param file_idx - The index of the file to detach.
   * @throws Error if session not initialized, filename missing, file not found, or API fails.
   */
  public async detachFile(file_idx: number): Promise<void> {
    this._ensureInitialized();

    const detachFileRequest: DetachFileRequest = {
      session_id: this.id,
      file_idx: file_idx,
    };

    // --- API Call ---
    let resp: OpResult;
    try {
      resp = await this.http.post<OpResult>(EndPointsEnum.DETACH_FILE, detachFileRequest);
    } catch (error: any) {
      console.error(`[Session][DetachFile][HTTP]: Network or client error`, error);
      throw new Error(`Detaching file failed due to a network error: ${error.message}`);
    }

    // --- Handle Response ---
    if (!resp || !resp.ok || resp.status_code !== ResponseStatusEnum.OK) {
      const errorMsg = `Detaching file failed: ${resp?.status_message || 'Unknown API error'} (Status: ${resp?.status_code})`;
      console.error(`[Session][DetachFile][API]: ${errorMsg}`);
      throw new Error(errorMsg);
    }

    console.info(`[Session][DetachFile][API]: File @ ${file_idx} detached from session ${this.id}.`);

    // Refreshing cached PublicSession
    await this.fetchSession();
  }


  // -- Logs --
  public async uploadAndAttachLogs(logs: Uint8Array): Promise<boolean> {
    this._ensureInitialized();
    throw 'not implemented yet';
    return false;
  }

  public async attachLogs(logsHash: string): Promise<boolean> {
    this._ensureInitialized();
    const params = {
      session_id: this.id,
      logs_hash: logsHash,
    };
    try {
      const resp = await this.http.post<OpResult>(
        LogsEndPointsEnum.ATTACH_LOGS,
        undefined,
        { params }
      );

      console.warn('response', resp);
      if (!resp || !resp.ok || resp.status_code !== ResponseStatusEnum.OK) {
        const errorMsg = `Attaching logs failed: ${
          resp?.status_message || 'Unknown API error'
        } (Status: ${resp?.status_code})`;
        console.error(`[Session][AttachLogs][API]: ${errorMsg}`);
        return false;
      }

      console.info(
        `[Session][AttachLogs] session_id=${this.id} logs_hash=${logsHash}: OK`
      );
      return true;
    } catch (error: any) {
      console.error(
        `[Session][AttachLogs][HTTP]: Network or client error`,
        error
      );
      return false;
    }
  }


  // --- Feedback ---

  /**
   * Sends user feedback about a specific interaction or the session.
   *
   * @param score - A numerical score for the feedback.
   * @param comment - A textual comment for the feedback.
   * @param groupId - Optional ID to group feedback related to a specific turn/interaction.
   * @throws Error if session not initialized or feedback submission fails.
   */
  public async sendFeedback(
    score: number,
    comment: string,
    groupId?: string // Changed to optional param
  ): Promise<void> {
    this._ensureInitialized();

    const feedback: Feedback = {
      session_id: this.id,
      type: FeedbackTypeEnum.USER_FEEDBACK as FeedbackType,
      score: score,
      comment: comment,
      group_id: groupId, // Assign if provided, else undefined
    };

    await this._uploadFeedback(feedback);
    console.info(`[Session][Feedback]: User feedback sent for session ${this.id}.`);
  }

  /**
   * Sends a bug report related to the session.
   *
   * @param bug - A description of the bug.
   * @param groupId - Optional ID to group the bug report with a specific turn/interaction.
   * @throws Error if session not initialized or bug report submission fails.
   */
  public async sendBugReport(
    bug: string,
    groupId?: string // Changed to optional param
  ): Promise<void> {
    this._ensureInitialized();

    const feedback: Feedback = {
      session_id: this.id,
      type: FeedbackTypeEnum.BUG_REPORT as FeedbackType,
      score: 0, // Score not applicable for bug reports
      comment: bug,
      group_id: groupId, // Assign if provided, else undefined
    };

    await this._uploadFeedback(feedback);
    console.info(`[Session][Feedback]: Bug report sent for session ${this.id}.`);
  }

  /** @internal Uploads feedback/bug report to the server. */
  private async _uploadFeedback(feedback: Feedback): Promise<void> {
    // --- API Call ---
    let resp: OpResult;
    try {
      // Ensure EndPointsEnum.SEND_FEEDBACK maps to '/v1/session/feedback'
      resp = await this.http.post<OpResult>(EndPointsEnum.SEND_FEEDBACK, feedback);
    } catch (error: any) {
      console.error(`[Session][FeedbackUpload][HTTP]: Network or client error`, error);
      throw new Error(`Feedback submission failed due to network/HTTP error: ${error.message}`);
    }

    // --- Handle Response ---
    if (!resp || !resp.ok || resp.status_code !== ResponseStatusEnum.OK) {
      const errorMsg = `Feedback submission failed: ${resp?.status_message || 'Unknown API error'} (Status: ${resp?.status_code})`;
      console.error(`[Session][FeedbackUpload][API]: ${errorMsg}`);
      throw new Error(errorMsg);
    }
    // Success, no return value needed for void function
  }

  // --- Utility & Private Methods ---

  /** Fetches the complete session object from the backend. */
  public async fetchSession(): Promise<PublicSessionOutput> {
    this._ensureInitialized();
    const session = await this._fetchSessionById(this.id);
    this._session = session; // Update cache
    return session;
  }

  /** @internal Fetches session by ID, handling errors. */
  private async _fetchSessionById(sessionId: string): Promise<PublicSessionOutput> {
    const queryParams = { session_id: sessionId };
    let respData: PublicSessionOutput | null;

    try {
      // Ensure EndPointsEnum.GET_SESSION maps to '/v1/session/get'
      respData = await this.http.get<PublicSessionOutput | null>(EndPointsEnum.GET_SESSION, queryParams);
    } catch (error: any) {
      console.error(`[Session][Fetch][HTTP]: Failed to fetch session ${sessionId}`, error);
      throw new Error(`Failed to fetch session ${sessionId} due to network/HTTP error: ${error.message}`);
    }

    // API might return 200 OK with null body if not found
    if (!respData) {
      throw new Error(`Session with ID '${sessionId}' not found or inaccessible.`);
    }
    return respData;
  }

  /** @internal Builds the basic Message object for a user query. */
  private _buildPromptMessage(prompt: string): Message {
    const msg: Message = {
      id: randomUUID(), // ID generated client-side for the request message
      parent_id: ROOT_MESSAGE_ID, // Assuming a root node for initial prompts
      role: RoleEnum.USER as Role,
      mime_type: MimeTypeEnum.TEXT_PLAIN as MimeType,
      state: StateEnum.QUERY as State,
      message_type: MessageTypeEnum.QUERY,
      content: prompt,
      // Other fields (turn, group, usage, status_*, timestamp) are typically set by backend
    };
    return msg;
  }

  /** @internal Checks if the session is initialized, throws if not. */
  private _ensureInitialized(): void {
    if (!this._session || !this._session.id) {
      throw new Error('Session operation failed: Session is not initialized. Call register() or resume() first.');
    }
  }

  /** Visualizes the session message tree in the console (basic implementation). */
  public async visualize(): Promise<void> {
    // Fetch latest session data before visualizing
    const session = await this.fetchSession();

    if (!session.messages || session.messages.length === 0) {
      console.log(`Session ${session.name} (${session.id}) has no messages yet.`);
      return;
    }

    console.log(`--- Session Visualization: ${session.name} (${session.id}) ---`);

    // Simple tree structure using indentation
    const messageMap = new Map<string, Message>();
    const childrenMap = new Map<string, string[]>();

    session.messages.forEach((msg) => {
      if (msg.id) messageMap.set(msg.id, msg);
      const parentId = msg.parent_id || ROOT_MESSAGE_ID;
      if (!childrenMap.has(parentId)) childrenMap.set(parentId, []);
      if (msg.id) childrenMap.get(parentId)?.push(msg.id);
    });

    function printNode(messageId: string, indent: string = '') {
      const msg = messageMap.get(messageId);
      if (!msg) return;

      const role = msg.role || 'N/A';
      const type = msg.message_type || 'N/A';
      let contentPreview = '';
      if (msg.mime_type?.startsWith('text/')) {
        contentPreview =
          (msg.content || '').substring(0, 80).replace(/\n/g, ' ') + ((msg.content?.length || 0) > 80 ? '...' : '');
      } else if (msg.mime_type) {
        contentPreview = `[${msg.mime_type}]`;
      } else {
        contentPreview = '[No Content]';
      }

      console.log(`${indent}[${role}|${type}] (${msg.id?.substring(0, 6)}...): ${contentPreview}`);

      const children = childrenMap.get(messageId) || [];
      children.forEach((childId) => printNode(childId, indent + '  '));
    }

    // Find root messages (those whose parent is ROOT_MESSAGE_ID or missing/null)
    const rootMessages = childrenMap.get(ROOT_MESSAGE_ID) || [];
    session.messages.forEach((msg) => {
      if (!msg.parent_id && msg.id && !rootMessages.includes(msg.id)) {
        // Also consider messages with no parent_id as roots, if not already captured
        const isChild = Array.from(childrenMap.values()).flat().includes(msg.id);
        if (!isChild) rootMessages.push(msg.id);
      }
    });

    if (rootMessages.length === 0 && session.messages.length > 0) {
      console.log('Could not determine root message(s). Printing all messages flat:');
      session.messages.forEach((msg) => printNode(msg.id!)); // Non-null assertion assuming IDs exist
    } else {
      console.log(`[ROOT] (${session.name} - ${session.usage?.total_tokens || 0} tokens)`);
      rootMessages.forEach((rootId) => printNode(rootId, '  '));
    }
    console.log(`--- End Visualization ---`);
  }
}
