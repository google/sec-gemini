/**
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import HttpClient from './http';
import InteractiveSession from './session';
import Streamer from './streamer';

// Manual enums (Ensure these are still relevant or update as needed)
import { EndPointsEnum, ResponseStatusEnum } from './enum';

// Rexport autogenerated types and enums
// Import specific types needed for the client and session interaction
import {
  // Base types often used
  Message,
  Usage,
  OpResult,
  MimeType, // If needed directly, else use MimeTypeEnum
  // Session related types
  PublicSessionInput, // Input for register/update/delete
  PublicSessionFile,
  PublicSessionOutput, // Output from get/list sessions
  SessionRequest, // Input for generate
  SessionResponse, // Output from generate

  // User and Model Info
  PublicUser,
  UserInfo,
  ModelInfoInput,
  // Other potentially useful types
  Attachment,
  Feedback,
  State, // String literal union type
} from './secgeminitypes'; // Adjusted imports

// Import relevant enums
import {
  RoleEnum,
  MessageTypeEnum,
  StateEnum, // Keep if used for default states etc.
  UserTypeEnum,
  MimeTypeEnum,
  FeedbackTypeEnum,
  // ModelNameEnum is removed
} from './secgeminienums';

// Define Constants for URLs
const DEFAULT_BASE_URL = 'https://api.secgemini.google';
const DEFAULT_WS_URL = 'wss://api.secgemini.google';
const DEFAULT_TTL = 86400; // Default session TTL in seconds

/**
 * Main client class for interacting with the SecGemini API.
 * Handles authentication, fetching user info, managing models,
 * and creating/resuming interactive sessions.
 */
export class SecGemini {
  private apiKey: string;
  private baseURL: string;
  private websocketsURL: string;
  private httpClient: HttpClient;

  // Store fetched user and model information
  private userInfo: UserInfo | null = null;
  private user: PublicUser | null = null; // Convenience accessor
  private stableModel: ModelInfoInput | null = null;
  private experimentalModel: ModelInfoInput | null = null;

  /**
   * Private constructor. Use the static `SecGemini.create()` method for instantiation.
   */
  private constructor(apiKey: string, baseURL: string, websocketsURL: string) {
    if (!apiKey) {
      throw new Error('API Key is required. Provide it directly or set SEC_GEMINI_API_KEY environment variable.');
    }

    this.apiKey = apiKey;
    // Ensure URLs don't have trailing slashes
    this.baseURL = (baseURL || DEFAULT_BASE_URL).replace(/\/$/, '');
    this.websocketsURL = (websocketsURL || DEFAULT_WS_URL).replace(/\/$/, '');

    // Validate URLs
    if (!this.baseURL.match(/^https?:\/\//)) {
      throw new Error(`Invalid baseURL "${this.baseURL}". Must start with http:// or https://`);
    }
    if (!this.websocketsURL.match(/^wss?:\/\//)) {
      throw new Error(`Invalid websocketsURL "${this.websocketsURL}". Must start with ws:// or wss://`);
    }

    this.httpClient = new HttpClient(this.baseURL, this.apiKey);
  }

  /**
   * Asynchronously creates and initializes a SecGemini client instance.
   * Fetches user information and available models upon creation.
   *
   * @param apiKey - The API key for authentication.
   * @param baseURL - Optional base URL for the HTTP API. Defaults to production URL.
   * @param websocketsURL - Optional URL for the WebSocket endpoint. Defaults to production URL.
   * @returns A Promise resolving to an initialized SecGemini instance.
   * @throws Error if API key is missing, user info cannot be fetched, or URLs are invalid.
   */
  public static async create(
    apiKey: string = '',
    baseURL: string = '',
    websocketsURL: string = ''
  ): Promise<SecGemini> {
    const sdk = new SecGemini(apiKey, baseURL, websocketsURL);

    try {
      // Fetch user info and available models
      // Ensure EndPointsEnum.USER_INFO maps to the correct endpoint '/v1/user/info'
      const userInfo = await sdk.httpClient.get<UserInfo>(EndPointsEnum.USER_INFO);

      if (!userInfo || !userInfo.user) {
        // Log the response if possible for debugging
        console.error('Invalid UserInfo received:', userInfo);
        throw new Error('Failed to fetch valid user information from API. Check API Key and endpoint.');
      }

      // Store user info
      sdk.userInfo = userInfo;
      sdk.user = userInfo.user;

      // Process available models
      sdk.processAvailableModels(userInfo.available_models);

      console.info('SecGemini SDK initialized successfully.'); // Use a proper logger if available
      return sdk;
    } catch (error: any) {
      // Log the underlying error if possible
      console.error('SecGemini initialization failed:', error);
      // Re-throw a more specific error
      if ((error instanceof Error && error.message.includes('401')) || error.message.includes('403')) {
        throw new Error(`Authentication failed. Please check your API Key. (Details: ${error.message})`);
      }
      throw new Error(`SecGemini initialization failed: ${error.message || error}`);
    }
  }

  /** Processes the list of available models and stores references. */
  private processAvailableModels(models?: ModelInfoInput[]): void {
    this.stableModel = null;
    this.experimentalModel = null;

    if (!models || models.length === 0) {
      console.warn('No available models found in UserInfo response.'); // Use logger
      return;
    }

    for (const model of models) {
      if (model.use_experimental) {
        if (!this.experimentalModel) {
          // Take the first experimental model found
          this.experimentalModel = model;
          console.info(`Found experimental model: ${model.model_string}`); // Use logger
        } else {
          console.warn(
            `Multiple experimental models found. Using the first one: ${this.experimentalModel.model_string}`
          ); // Use logger
        }
      } else {
        if (!this.stableModel) {
          // Take the first stable model found
          this.stableModel = model;
          console.info(`Found stable model: ${model.model_string}`); // Use logger
        } else {
          console.warn(`Multiple stable models found. Using the first one: ${this.stableModel.model_string}`); // Use logger
        }
      }
    }

    if (!this.stableModel) {
      console.warn('No stable model found.'); // Use logger
    }
    if (!this.experimentalModel && this.user?.allow_experimental) {
      console.warn('No experimental model found, although user might be allowed to use them.'); // Use logger
    }
  }

  // --- Getters ---

  public getApiKey(): string {
    return this.apiKey;
  }

  public getBaseUrl(): string {
    return this.baseURL;
  }

  public getWebsocketsUrl(): string {
    return this.websocketsURL;
  }

  /**
   * Gets the cached UserInfo object fetched during initialization.
   * @returns The UserInfo object or null if initialization failed.
   */
  public getUserInfo(): UserInfo | null {
    return this.userInfo;
  }

  /**
   * Gets the cached PublicUser object fetched during initialization.
   * @returns The PublicUser object or null if initialization failed.
   */
  public getUser(): PublicUser | null {
    return this.user;
  }

  /**
   * Gets the identified stable ModelInfoInput object.
   * @returns The stable ModelInfoInput object or null if none was found/available.
   */
  public getStableModel(): ModelInfoInput | null {
    return this.stableModel;
  }

  /**
   * Gets the identified experimental ModelInfoInput object.
   * @returns The experimental ModelInfoInput object or null if none was found/available.
   */
  public getExperimentalModel(): ModelInfoInput | null {
    return this.experimentalModel;
  }

  // --- Session Management ---

  /**
   * Creates and registers a new interactive session.
   *
   * @param options - Configuration options for the new session.
   * @param options.ttl - Time-to-live for the session in seconds. Defaults to 86400 (24 hours).
   * @param options.name - Optional human-readable name for the session. Autogenerated if empty.
   * @param options.description - Optional description for the session.
   * @param options.logSession - Whether to enable logging for this session (subject to user permissions). Defaults to true.
   * @param options.model - The model to use. Can be 'stable', 'experimental', or a specific ModelInfoInput object. Defaults to 'stable'.
   * @param options.language - ISO language code for the session. Defaults to 'en'.
   * @returns A Promise resolving to the newly created and registered InteractiveSession.
   * @throws Error if user info is missing, the selected model is unavailable/disallowed, or registration fails.
   */
  public async createSession(
    options: {
      ttl?: number;
      name?: string;
      description?: string;
      logSession?: boolean;
      model?: 'stable' | 'experimental' | ModelInfoInput;
      language?: string;
      id?: string; // Optional session ID, autogenerated if not provided.
    } = {}
  ): Promise<InteractiveSession> {
    const {
      ttl = DEFAULT_TTL,
      name = '',
      description = '',
      logSession = true,
      model = 'stable',
      language = 'en',
      id = '',
    } = options;

    if (!this.user) {
      throw new Error('Cannot create session: User information not available. SDK might not be initialized correctly.');
    }

    // --- Resolve the Model ---
    let resolvedModel: ModelInfoInput;
    if (typeof model === 'string') {
      if (model === 'stable') {
        if (!this.stableModel) throw new Error('Cannot create session: Stable model is not available.');
        resolvedModel = this.stableModel;
      } else if (model === 'experimental') {
        if (!this.experimentalModel) throw new Error('Cannot create session: Experimental model is not available.');
        // Check if user is allowed to use experimental models
        if (!this.user.allow_experimental) {
          throw new Error('Cannot create session: User is not authorized to use experimental models.');
        }
        resolvedModel = this.experimentalModel;
      } else {
        throw new Error(
          `Invalid model identifier string: '${model}'. Use 'stable', 'experimental', or provide a ModelInfoInput object.`
        );
      }
    } else if (typeof model === 'object' && model !== null && model.model_string) {
      // Basic check if it looks like a ModelInfoInput object
      // More robust validation could be added if needed
      resolvedModel = model;
      // Optional: Check if this model is actually in the user's available_models list?
      const modelIsAvailable = this.userInfo?.available_models?.some(
        (m) => m.model_string === resolvedModel.model_string
      );
      if (!modelIsAvailable) {
        console.warn(
          `Using provided ModelInfoInput for '${resolvedModel.model_string}', but it wasn't listed in available models.`
        ); // Use logger
      }
      if (resolvedModel.use_experimental && !this.user.allow_experimental) {
        throw new Error(
          `Cannot create session with provided experimental model '${resolvedModel.model_string}': User is not authorized.`
        );
      }
    } else {
      throw new Error("Invalid model parameter provided. Use 'stable', 'experimental', or a ModelInfoInput object.");
    }
    // --- End Model Resolution ---

    // --- Create InteractiveSession Instance ---
    // Constructor now only takes dependencies, no model info yet.
    const session = new InteractiveSession(
      this.user,
      this.httpClient,
      this.websocketsURL, // Pass the correct websocket URL
      this.apiKey,
      logSession // Pass initial logging preference
    );

    // --- Register the Session ---
    // Register method now requires the resolved ModelInfoInput.
    // We'll need to update InteractiveSession.register signature later.
    // Using an options object for register for clarity.
    await session.register({
      ttl,
      model: resolvedModel, // Pass the resolved ModelInfoInput here!
      name,
      description,
      language,
      id,
      // logSession is handled by the constructor and initial checks now
    });

    console.info(`Session created successfully: ${session.id}`); // Use logger
    return session;
  }

  /**
   * Resumes an existing interactive session by its ID.
   *
   * @param sessionId - The ID of the session to resume.
   * @returns A Promise resolving to the resumed InteractiveSession.
   * @throws Error if user info is missing or the session cannot be resumed.
   */
  public async resumeSession(sessionId: string): Promise<InteractiveSession> {
    if (!this.user) {
      throw new Error('Cannot resume session: User information not available. SDK might not be initialized correctly.');
    }
    if (!sessionId) {
      throw new Error('Cannot resume session: Session ID must be provided.');
    }

    // Constructor doesn't need model info or initial log preference for resume
    const session = new InteractiveSession(
      this.user,
      this.httpClient,
      this.websocketsURL,
      this.apiKey
      // logSession preference is determined by the resumed session's state
    );

    const success = await session.resume(sessionId);
    if (!success) {
      // session.resume should ideally throw a more specific error if possible
      throw new Error(`Failed to resume session with ID: ${sessionId}. Session may not exist or is inaccessible.`);
    }

    console.info(`Session resumed successfully: ${sessionId}`); // Use logger
    return session;
  }

  // TODO: Add methods corresponding to Python's list_sessions, list_models, display_info if needed.
  // Example:
  // public async listSessions(): Promise<PublicSessionOutput[]> {
  //    // Need an endpoint for this, '/v1/session/list' ?
  //    // const sessions = await this.httpClient.get<PublicSessionOutput[]>(EndPointsEnum.LIST_SESSIONS);
  //    // return sessions;
  //    throw new Error("listSessions not implemented yet.");
  // }
}

// --- Exports ---
// Export the main client class as default
export { SecGemini as default };

// Export core classes and types for SDK users
export {
  // Classes
  InteractiveSession,
  Streamer, // Assuming Streamer is still needed and updated
  // Core Types
  PublicUser,
  UserInfo,
  ModelInfoInput,
  Message,
  Usage,
  Attachment,
  Feedback,
  OpResult,
  // Session Interaction Types
  PublicSessionInput,
  PublicSessionOutput,
  PublicSessionFile,
  SessionRequest,
  SessionResponse,
  State, // State string literal union type
  MimeType, // MimeType string literal union type
  // Core Enums (consider if all are needed externally)
  RoleEnum,
  MessageTypeEnum,
  StateEnum,
  UserTypeEnum,
  MimeTypeEnum,
  FeedbackTypeEnum,
  ResponseStatusEnum, // If used for interpreting OpResult status codes
};

// Define potentially useful aliases if desired (optional)
export type User = PublicUser;
export type Session = PublicSessionOutput; // Common alias for session state
