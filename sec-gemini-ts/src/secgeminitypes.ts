/**
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is auto-generated by @hey-api/openapi-ts

/**
 * Represents a file upload to the session.
 */
export type Attachment = {
  /**
   * The session ID this file should be attached to.
   */
  session_id: string;
  /**
   * The name of the file.
   */
  filename: string;
  /**
   * The mime type of the file. This is used as a hint, and it may be ignored.
   */
  mime_type?: string;
  /**
   * The content of the file as string. Always base64 encoded.
   */
  content: string;
};

export type DetachFileRequest = {
  /**
   * The session ID the file should be detached from.
   */
  session_id: string;
  /**
   * The index of the files to detach.
   */
  file_idx: number;
};

export type ChatCompletionRequest = {
  model: string;
  messages: Array<OpenAiMessage>;
  temperature?: number | null;
  top_p?: number | null;
  n?: number | null;
  stream?: boolean | null;
  max_tokens?: number | null;
  presence_penalty?: number | null;
  frequency_penalty?: number | null;
  user?: string | null;
  metadata?: { [key: string]: unknown } | null;
};

export type ChatCompletionResponse = {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<Choice>;
  usage: OpenAiUsage;
};

export type Choice = { index: number; message: OpenAiMessage; finish_reason: string };

/**
 * Represents a feedback to the session.
 */
export type Feedback = {
  /**
   * The session ID this feedback should be attached to.
   */
  session_id: string;
  /**
   * The message group ID this feedback should be attached to.
   */
  group_id?: string;
  /**
   * The type of feedback.
   */
  type: FeedbackType;
  /**
   * The score of the feedback.
   */
  score: number;
  /**
   * The comment of the feedback.
   */
  comment: string;
};

/**
 * Type of feedback that can be sent to the system.
 */
export type FeedbackType = 'user_feedback' | 'bug_report';

export type HttpValidationError = { detail?: Array<ValidationError> };

/**
 * Represents the content of the session both in request and response.
 */
export type Message = {
  /**
   * A unique identifier for the message - uuid4 int.
   */
  id?: string;
  /**
   * The ID of the parent message.
   */
  parent_id?: string;
  /**
   * The turn identifier is used to group/message are part of the same conversation turn.
   */
  turn?: string;
  /**
   * The Group ID (UUID4) identify messages part of the same generation or action.
   */
  group?: string;
  /**
   * The actor of the message - user or agent.
   */
  actor?: string;
  /**
   * The role of the messages author.
   */
  role?: Role;
  /**
   * The Unix timestamp (in seconds) of when the message was created.
   */
  timestamp?: number;
  /**
   * The type of message - Generation, Tool Call, or Info.
   */
  message_type: MessageType;
  /**
   * The sub type of the message - e.g. function name.
   */
  message_sub_type?: string | null;
  /**
   * The state the message belongs to.
   */
  state?: State;
  /**
   * The content of the message encoded as utf-8 bytes.
   */
  content?: string | null;
  /**
   * The content type of the content field.
   */
  mime_type?: MimeType | null;
  /**
   * The status code of the message. 2xx is Okay, 4xx is a client error, 5xx is a server error.
   */
  status_code?: number;
  /**
   * Explain status code reason.
   */
  status_message?: string;
  /**
   * Token counts when message was generated by model.
   */
  usage?: Usage | null;
};

/**
 * Type of message
 */
export type MessageType =
  | 'result'
  | 'source'
  | 'debug'
  | 'info'
  | 'error'
  | 'thinking'
  | 'update'
  | 'delete'
  | 'confirmation_request'
  | 'confirmation_response'
  | 'query'
  | 'response_complete';

/**
 * Completion type
 */
export type MimeType =
  | 'text/plain'
  | 'text/markdown'
  | 'text/serialized-json'
  | 'application/octet-stream'
  | 'image/jpeg'
  | 'image/png'
  | 'image/tiff'
  | 'image/gif'
  | 'image/svg+xml'
  | 'image/webp'
  | 'image/avif'
  | 'audio/wav'
  | 'audio/mpeg'
  | 'audio/ogg'
  | 'video/webm'
  | 'video/mp4'
  | 'text/c'
  | 'text/c++'
  | 'text/java'
  | 'text/rust'
  | 'text/go'
  | 'text/python'
  | 'text/php'
  | 'text/perl'
  | 'text/ruby'
  | 'text/swift'
  | 'text/kotlin'
  | 'text/scala'
  | 'text/javascript'
  | 'text/typescript'
  | 'text/html'
  | 'text/css'
  | 'text/csv'
  | 'text/xml'
  | 'text/yaml'
  | 'text/toml'
  | 'text/sql'
  | 'application/json'
  | 'application/jsonl'
  | 'application/pdf'
  | 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
  | 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  | 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
  | 'application/msword'
  | 'application/vnd.ms-excel'
  | 'application/vnd.ms-powerpoint'
  | 'application/rtf'
  | 'application/vnd.oasis.opendocument.text';

/**
 * Describes a Sec-Gemini model.
 */
export type ModelInfoInput = {
  /**
   * Model name.
   */
  model_name?: string;
  /**
   * The string used to identify the model.
   */
  model_string: string;
  /**
   * The version of the model.
   */
  version: string;
  /**
   * Whether the model is experimental or not.
   */
  use_experimental?: boolean;
  /**
   * Description of the agent.
   */
  description?: string;
  /**
   * Toggable tools used by the model.
   */
  toolsets?: Array<OptionalToolSet>;
};

/**
 * Describes a Sec-Gemini model.
 */
export type ModelInfoOutput = {
  /**
   * Model name.
   */
  model_name?: string;
  /**
   * The string used to identify the model.
   */
  model_string: string;
  /**
   * The version of the model.
   */
  version: string;
  /**
   * Whether the model is experimental or not.
   */
  use_experimental?: boolean;
  /**
   * Description of the agent.
   */
  description?: string;
  /**
   * Toggable tools used by the model.
   */
  toolsets?: Array<OptionalToolSet>;
};

export type OpResult = {
  /**
   * True if the operation was successful.
   */
  ok: boolean;
  /**
   * HTTP status code to return.
   */
  status_code: ResponseStatus;
  /**
   * Describe why the operation failed.
   */
  status_message?: string;
  /**
   * Optional field for additional information.
   */
  data?: { [key: string]: unknown } | null;
  /**
   * The type of data in the data field.
   */
  mime_type?: MimeType | null;
  /**
   * The time taken to complete the request in seconds.
   */
  latency?: number | null;
};

export type OpenAiContent = { type: string; text: string };

export type OpenAiMessage = { role: 'system' | 'user' | 'assistant'; content: string | Array<OpenAiContent> };

export type OpenAiUsage = { prompt_tokens: number; completion_tokens: number; total_tokens: number };

/**
 * Describes the toolsets of a Sec-Gemini model.
 */
export type OptionalToolSet = {
  /**
   * The name of the toolset.
   */
  name: string;
  /**
   * The version of the toolset.
   */
  version: number;
  /**
   * A brief description of the toolset.
   */
  description?: string | null;
  /**
   * The vendor of the toolset.
   */
  vendor: ToolSetVendor;
  /**
   * Whether the toolset is enabled or not.
   */
  is_enabled?: boolean;
  /**
   * Whether the toolset is experimental or not.
   */
  is_experimental?: boolean;
};

/**
 * Only add the fields necessary to show to users.
 */
export type PublicSessionInput = {
  /**
   * Session unique ramdom identifier.
   */
  id?: string;
  /**
   * The user ID this session belongs to.
   */
  user_id: string;
  /**
   * The organization ID this session belongs to.
   */
  org_id: string;
  /**
   * Model configuration used in the session.
   */
  model: ModelInfoInput;
  /**
   * The time to live of the session in seconds.
   */
  ttl: number;
  /**
   * The iso-code of the session language.
   */
  language?: string;
  /**
   * The number of turns in the session.
   */
  turns?: number;
  /**
   * Human readable session name.
   */
  name: string;
  /**
   * A brief description to help users remember what the session is about.
   */
  description: string;
  /**
   * The Unix timestamp of when the session was created.
   */
  create_time?: number;
  /**
   * The Unix timestamp of when the session was last updated.
   */
  update_time?: number;
  /**
   * The number of messages in the session.
   */
  num_messages?: number;
  /**
   * The list of messages comprising the session so far.
   */
  messages?: Array<Message>;
  /**
   * Session usage statistics.
   */
  usage?: Usage;
  /**
   * Whether the session can be logged or not.
   */
  can_log?: boolean;
  /**
   * The state the session belongs to.
   */
  state?: State;
  /**
   * The list of files uploaded to the session.
   */
  files?: Array<PublicSessionFile>;
};

/**
 * Only add the fields necessary to show to users.
 */
export type PublicSessionOutput = {
  /**
   * Session unique ramdom identifier.
   */
  id?: string;
  /**
   * The user ID this session belongs to.
   */
  user_id: string;
  /**
   * The organization ID this session belongs to.
   */
  org_id: string;
  /**
   * Model configuration used in the session.
   */
  model: ModelInfoOutput;
  /**
   * The time to live of the session in seconds.
   */
  ttl: number;
  /**
   * The iso-code of the session language.
   */
  language?: string;
  /**
   * The number of turns in the session.
   */
  turns?: number;
  /**
   * Human readable session name.
   */
  name: string;
  /**
   * A brief description to help users remember what the session is about.
   */
  description: string;
  /**
   * The Unix timestamp (in seconds) of when the session was created.
   */
  create_time?: number;
  /**
   * The Unix timestamp (in seconds) of when the session was last updated.
   */
  update_time?: number;
  /**
   * The number of messages in the session.
   */
  num_messages?: number;
  /**
   * The list of messages comprising the session so far.
   */
  messages?: Array<Message>;
  /**
   * Session usage statistics.
   */
  usage?: Usage;
  /**
   * Whether the session can be logged or not.
   */
  can_log?: boolean;
  /**
   * The state the session belongs to.
   */
  state?: State;
  /**
   * The list of files uploaded to the session.
   */
  files?: Array<PublicSessionFile>;
};

/**
 * Only add the fields necessary to show to users.
 */
export type PublicSessionFile = {
  /**
   * The original name of the file.
   */
  name: string;
  /**
   * Size of the file.
   */
  size?: number;
  /**
   * SHA256 of the file.
   */
  sha256?: string;
  /**
   * The mime type of the file.
   */
  mime_type: string;
  /**
   * A simple label to identify the content type.
   */
  content_type_label?: string;
};

/**
 * Only add the fields necessary to show to users.
 */
export type PublicUser = {
  /**
   * The user ID this session belongs to.
   */
  id: string;
  /**
   * The organization ID this session belongs to.
   */
  org_id: string;
  /**
   * The type of user.
   */
  type?: UserType;
  /**
   * The user session should never be logged.
   */
  never_log?: boolean;
  /**
   * Is user authorized to disable logging.
   */
  can_disable_logging?: boolean;
  /**
   * The Unix timestamp (in seconds) of when the key will expire.
   */
  key_expire_time?: number;
  /**
   * Tokens per minute quota.
   */
  tpm?: number;
  /**
   * Requests per minute quota.
   */
  rpm?: number;
  /**
   * Whether the user is allowed to use experimental features.
   */
  allow_experimental?: boolean;
  /**
   * The list of vendors the user has access to.
   */
  vendors?: Array<PublicUserVendor>;
};

export type PublicUserVendor = { name: string; description: string; url: string; svg: string };

export type ResponseStatus =
  | 200
  | 201
  | 202
  | 204
  | 206
  | 300
  | 301
  | 302
  | 303
  | 304
  | 307
  | 308
  | 400
  | 401
  | 402
  | 403
  | 404
  | 405
  | 406
  | 407
  | 408
  | 409
  | 410
  | 411
  | 412
  | 413
  | 414
  | 415
  | 416
  | 417
  | 418
  | 422
  | 425
  | 426
  | 428
  | 429
  | 431
  | 451
  | 500
  | 501
  | 502
  | 503
  | 504
  | 505
  | 506
  | 507
  | 508
  | 510
  | 511;

/**
 * Describe the role associated with the completion
 */
export type Role = 'user' | 'agent' | 'system';

/**
 * Schema for the request body for triggering a model generation.
 */
export type SessionRequest = {
  /**
   * The Session ID (UUID4) this request belongs to.
   */
  id?: string;
  /**
   * new query messages
   */
  messages: Array<Message>;
};

export type SessionResponse = {
  id: string;
  messages: Array<Message>;
  /**
   * The status code of the message. 2xx is Okay, 4xx is a client error, 5xx is a server error.
   */
  status_code: number;
  /**
   * Explain status code reason.
   */
  status_message: string;
  /**
   * Usage statistics for the message.
   */
  usage: Usage;
};

export type State =
  | 'start'
  | 'query'
  | 'running_agent'
  | 'agent_done'
  | 'coding'
  | 'code_result'
  | 'calling_tool'
  | 'tool_result'
  | 'generating'
  | 'answering'
  | 'thinking'
  | 'planning'
  | 'reviewing'
  | 'understanding'
  | 'retriving'
  | 'grounding';

/**
 * Vendor Toolsets info.
 */
export type ToolSetVendor = {
  /**
   * The name of the vendor providing the tool or agent.
   */
  name: string;
  /**
   * A brief description of the vendor.
   */
  description: string;
  /**
   * The URL of vendor.
   */
  url: string;
  /**
   * The SVG icon of the vendor.
   */
  svg: string;
};

/**
 * Tracks token usage for a chat completion request and response.
 */
export type Usage = {
  /**
   * Number of tokens in the prompt
   */
  prompt_tokens?: number;
  /**
   * Number of tokens used during generation
   */
  generated_tokens?: number;
  /**
   * Total number of tokens used in the request (prompt + generation)
   */
  total_tokens?: number;
};

export type UserInfo = {
  /**
   * The user information.
   */
  user: PublicUser;
  /**
   * The list of users active sessions.
   */
  sessions?: Array<PublicSessionOutput>;
  /**
   * The list of models available to the user.
   */
  available_models?: Array<ModelInfoOutput>;
};

/**
 * User type
 */
export type UserType = 'ui' | 'user' | 'admin' | 'system' | 'service';

export type ValidationError = { loc: Array<string | number>; msg: string; type: string };

export type FeedbackV1SessionFeedbackPostData = {
  body: Feedback;
  path?: never;
  query?: never;
  url: '/v1/session/feedback';
};

export type FeedbackV1SessionFeedbackPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type FeedbackV1SessionFeedbackPostError =
  FeedbackV1SessionFeedbackPostErrors[keyof FeedbackV1SessionFeedbackPostErrors];

export type FeedbackV1SessionFeedbackPostResponses = {
  /**
   * Successful Response
   */
  200: OpResult;
};

export type FeedbackV1SessionFeedbackPostResponse =
  FeedbackV1SessionFeedbackPostResponses[keyof FeedbackV1SessionFeedbackPostResponses];

export type RegisterV1SessionRegisterPostData = {
  body: PublicSessionInput;
  path?: never;
  query?: never;
  url: '/v1/session/register';
};

export type RegisterV1SessionRegisterPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type RegisterV1SessionRegisterPostError =
  RegisterV1SessionRegisterPostErrors[keyof RegisterV1SessionRegisterPostErrors];

export type RegisterV1SessionRegisterPostResponses = {
  /**
   * Successful Response
   */
  200: OpResult;
};

export type RegisterV1SessionRegisterPostResponse =
  RegisterV1SessionRegisterPostResponses[keyof RegisterV1SessionRegisterPostResponses];

export type UpdateV1SessionUpdatePostData = {
  body: PublicSessionInput;
  path?: never;
  query?: never;
  url: '/v1/session/update';
};

export type UpdateV1SessionUpdatePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type UpdateV1SessionUpdatePostError = UpdateV1SessionUpdatePostErrors[keyof UpdateV1SessionUpdatePostErrors];

export type UpdateV1SessionUpdatePostResponses = {
  /**
   * Successful Response
   */
  200: OpResult;
};

export type UpdateV1SessionUpdatePostResponse =
  UpdateV1SessionUpdatePostResponses[keyof UpdateV1SessionUpdatePostResponses];

export type DeleteFileV1SessionDeleteFilePostData = {
  body: Attachment;
  path?: never;
  query?: never;
  url: '/v1/session/delete_file';
};

export type DeleteFileV1SessionDeleteFilePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteFileV1SessionDeleteFilePostError =
  DeleteFileV1SessionDeleteFilePostErrors[keyof DeleteFileV1SessionDeleteFilePostErrors];

export type DeleteFileV1SessionDeleteFilePostResponses = {
  /**
   * Successful Response
   */
  200: OpResult;
};

export type DeleteFileV1SessionDeleteFilePostResponse =
  DeleteFileV1SessionDeleteFilePostResponses[keyof DeleteFileV1SessionDeleteFilePostResponses];

export type AttachV1SessionAttachFilePostData = {
  body: Attachment;
  path?: never;
  query?: never;
  url: '/v1/session/attach_file';
};

export type AttachV1SessionAttachFilePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type AttachV1SessionAttachFilePostError =
  AttachV1SessionAttachFilePostErrors[keyof AttachV1SessionAttachFilePostErrors];

export type AttachV1SessionAttachFilePostResponses = {
  /**
   * Successful Response
   */
  200: OpResult;
};

export type AttachV1SessionAttachFilePostResponse =
  AttachV1SessionAttachFilePostResponses[keyof AttachV1SessionAttachFilePostResponses];

export type DeleteV1SessionDeletePostData = {
  body: PublicSessionInput;
  path?: never;
  query?: never;
  url: '/v1/session/delete';
};

export type DeleteV1SessionDeletePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type DeleteV1SessionDeletePostError = DeleteV1SessionDeletePostErrors[keyof DeleteV1SessionDeletePostErrors];

export type DeleteV1SessionDeletePostResponses = {
  /**
   * Successful Response
   */
  200: OpResult;
};

export type DeleteV1SessionDeletePostResponse =
  DeleteV1SessionDeletePostResponses[keyof DeleteV1SessionDeletePostResponses];

export type ListV1SessionListGetData = { body?: never; path?: never; query?: never; url: '/v1/session/list' };

export type ListV1SessionListGetResponses = {
  /**
   * Successful Response
   */
  200: Array<PublicSessionOutput>;
};

export type ListV1SessionListGetResponse = ListV1SessionListGetResponses[keyof ListV1SessionListGetResponses];

export type GetV1SessionGetGetData = {
  body?: never;
  path?: never;
  query: { session_id: string };
  url: '/v1/session/get';
};

export type GetV1SessionGetGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetV1SessionGetGetError = GetV1SessionGetGetErrors[keyof GetV1SessionGetGetErrors];

export type GetV1SessionGetGetResponses = {
  /**
   * Successful Response
   */
  200: PublicSessionOutput | null;
};

export type GetV1SessionGetGetResponse = GetV1SessionGetGetResponses[keyof GetV1SessionGetGetResponses];

export type GenerateV1SessionGeneratePostData = {
  body: SessionRequest;
  path?: never;
  query?: never;
  url: '/v1/session/generate';
};

export type GenerateV1SessionGeneratePostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GenerateV1SessionGeneratePostError =
  GenerateV1SessionGeneratePostErrors[keyof GenerateV1SessionGeneratePostErrors];

export type GenerateV1SessionGeneratePostResponses = {
  /**
   * Successful Response
   */
  200: SessionResponse;
};

export type GenerateV1SessionGeneratePostResponse =
  GenerateV1SessionGeneratePostResponses[keyof GenerateV1SessionGeneratePostResponses];

export type InfoV1UserInfoGetData = { body?: never; path?: never; query?: never; url: '/v1/user/info' };

export type InfoV1UserInfoGetResponses = {
  /**
   * Successful Response
   */
  200: UserInfo;
};

export type InfoV1UserInfoGetResponse = InfoV1UserInfoGetResponses[keyof InfoV1UserInfoGetResponses];

export type CompleteChatCompletionsPostData = {
  body: ChatCompletionRequest;
  path?: never;
  query?: never;
  url: '/chat/completions';
};

export type CompleteChatCompletionsPostErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type CompleteChatCompletionsPostError =
  CompleteChatCompletionsPostErrors[keyof CompleteChatCompletionsPostErrors];

export type CompleteChatCompletionsPostResponses = {
  /**
   * Successful Response
   */
  200: ChatCompletionResponse;
};

export type CompleteChatCompletionsPostResponse =
  CompleteChatCompletionsPostResponses[keyof CompleteChatCompletionsPostResponses];

export type TsMockV1ExperimentalTsGetData = { body?: never; path?: never; query?: never; url: '/v1/experimental/ts' };

export type TsMockV1ExperimentalTsGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetAgentV1SystemAgentGetData = {
  body?: never;
  path?: never;
  query?: { height?: number; experimental?: boolean };
  url: '/v1/system/agent';
};

export type GetAgentV1SystemAgentGetErrors = {
  /**
   * Validation Error
   */
  422: HttpValidationError;
};

export type GetAgentV1SystemAgentGetError = GetAgentV1SystemAgentGetErrors[keyof GetAgentV1SystemAgentGetErrors];

export type GetAgentV1SystemAgentGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type GetAgentGraphV1SystemAgentGraphGetData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v1/system/agent_graph';
};

export type GetAgentGraphV1SystemAgentGraphGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type DiagnosticsV1SystemDiagnosticGetData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v1/system/diagnostic';
};

export type DiagnosticsV1SystemDiagnosticGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type HealthCheckHealthGetData = { body?: never; path?: never; query?: never; url: '/health' };

export type HealthCheckHealthGetResponses = {
  /**
   * Successful Response
   */
  200: { [key: string]: unknown };
};

export type HealthCheckHealthGetResponse = HealthCheckHealthGetResponses[keyof HealthCheckHealthGetResponses];

export type GetGetData = { body?: never; path?: never; query?: never; url: '/' };

export type GetGetResponses = {
  /**
   * Successful Response
   */
  200: unknown;
};

export type ClientOptions = { baseUrl: `${string}://${string}` | (string & {}) };
