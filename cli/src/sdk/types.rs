// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::collections::BTreeMap;

use serde::{Deserialize, Serialize};
use serde_json::Value;
use serde_with::rust::double_option;
use serde_with::skip_serializing_none;

/// Represents the content of the session both in request and response.
#[skip_serializing_none]
#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(default, deny_unknown_fields)]
pub struct Message {
    /// A unique identifier for the message - uuid4 int.
    pub id: Option<String>,
    /// The ID of the parent message.
    pub parent_id: Option<String>,
    /// The turn identifier is used to group/message are part of the same conversation turn.
    pub turn: Option<String>,
    /// The Group ID (UUID4) identify messages part of the same generation or action.
    pub group: Option<String>,
    /// The actor of the message - user or agent.
    pub actor: Option<String>,
    /// The role of the messages author.
    pub role: Option<Role>,
    /// The Unix timestamp (in seconds) of when the message was created.
    pub timestamp: Option<u64>,
    /// The type of message - Generation, Tool Call, or Info.
    pub message_type: MessageType,
    /// The sub type of the message - e.g. function name.
    #[serde(default, with = "double_option")]
    pub message_sub_type: Option<Option<String>>,
    /// The state the message belongs to.
    pub state: Option<State>,
    /// The content of the message encoded as utf-8 bytes.
    #[serde(default, with = "double_option")]
    pub content: Option<Option<String>>,
    /// The content type of the content field.
    #[serde(default, with = "double_option")]
    pub mime_type: Option<Option<MimeType>>,
    /// The status code of the message. 2xx is Okay, 4xx is a client error, 5xx is a server error.
    pub status_code: Option<u16>,
    /// Explain status code reason.
    pub status_message: Option<String>,
    /// Token counts when message was generated by model.
    #[serde(default, with = "double_option")]
    pub usage: Option<Option<Usage>>,
}

/// Type of message
#[derive(Debug, Default, Clone, Copy, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum MessageType {
    Result,
    Source,
    Debug,
    Info,
    Error,
    Thinking,
    Update,
    Delete,
    ConfirmationRequest,
    ConfirmationResponse,
    #[default]
    Query,
}

/// Completion type
pub type MimeType = String; // we don't try to list them at this point

pub type ModelInfoInput = ModelInfoOutput; // it's the same

/// Describes a Sec-Gemini model.
#[skip_serializing_none]
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct ModelInfoOutput {
    /// The string used to identify the model.
    pub model_string: String,
    /// The version of the model.
    pub version: String,
    /// Whether the model is experimental or not.
    pub is_experimental: Option<bool>,
    /// Toggable tools used by the model.
    toolsets: Option<Vec<OptionalToolSet>>,
}

#[skip_serializing_none]
#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct OpResult {
    /// True if the operation was successful.
    pub ok: bool,
    /// HTTP status code to return.
    status_code: u16,
    /// Describe why the operation failed.
    pub status_message: Option<String>,
    /// Optional field for additional information.
    #[serde(default, with = "double_option")]
    data: Option<Option<BTreeMap<String, Value>>>,
    /// The type of data in the data field.
    #[serde(default, with = "double_option")]
    mime_type: Option<Option<MimeType>>,
    /// The time taken to complete the request in seconds.
    #[serde(default, with = "double_option")]
    latency: Option<Option<f64>>,
}

type OptionalToolSet = Value; // we don't use them

pub type PublicSessionInput = PublicSessionOutput; // it's the same

#[skip_serializing_none]
#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct PublicSessionOutput {
    /// Session unique ramdom identifier.
    pub id: Option<String>,
    /// The user ID this session belongs to.
    pub user_id: String,
    /// The organization ID this session belongs to.
    pub org_id: String,
    /// Model configuration used in the session.
    pub model: ModelInfoOutput,
    /// The time to live of the session in seconds.
    pub ttl: u64,
    /// The iso-code of the session language.
    pub language: Option<String>,
    /// The number of turns in the session.
    pub turns: Option<u64>,
    /// Human readable session name.
    pub name: String,
    /// A brief description to help users remember what the session is about.
    pub description: String,
    /// The Unix timestamp (in seconds) of when the session was created.
    pub create_time: Option<u64>,
    /// The Unix timestamp (in seconds) of when the session was last updated.
    pub update_time: Option<u64>,
    /// The number of messages in the session.
    pub num_messages: Option<u64>,
    /// The list of messages comprising the session so far.
    pub messages: Option<Vec<Message>>,
    /// Session usage statistics.
    pub usage: Option<Usage>,
    /// Whether the session can be logged or not.
    pub can_log: Option<bool>,
    /// The state the session belongs to.
    pub state: Option<State>,
    /// The list of files uploaded to the session.
    pub files: Option<Vec<PublicSessionFile>>,
}

type PublicSessionFile = Value; // we don't use them

#[skip_serializing_none]
#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct PublicUser {
    /// The unique identifier for the user.
    pub id: String,
    /// User organization.
    pub org_id: String,
    /// The type of user.
    #[serde(rename = "type")]
    type_: Option<UserType>,
    /// The user session should never be logged.
    pub never_log: Option<bool>,
    /// Is user authorized to disable logging.
    can_disable_logging: Option<bool>,
    /// The Unix timestamp (in seconds) of when the key will expire.
    key_expire_time: Option<u64>,
    /// Tokens per minute quota.
    tpm: Option<u64>,
    /// Requests per minute quota.
    rpm: Option<u64>,
    /// Whether the user is allowed to use experimental features.
    allow_experimental: Option<bool>,
    /// The list of vendors the user has access to.
    vendors: Option<Vec<PublicUserVendor>>,
}

type PublicUserVendor = Value; // we don't use them

/// Describe the role associated with the completion
#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Role {
    #[default]
    User,
    Agent,
    System,
}

/// Schema for the request body for triggering a model generation.
#[skip_serializing_none]
#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
struct SessionRequest {
    /// The Session ID (UUID4) this request belongs to.
    id: Option<String>,
    /// A message or list of messages comprising the conversation so far.
    messages: Vec<Message>,
}

/// Represents a generation response returned by the model, based on the provided input.
#[skip_serializing_none]
#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
struct SessionResponse {
    /// The Session ID (UUID4) passed in the request.
    id: String,
    /// A list of generated message. Can be more than one if `n` is greater than 1.
    messages: Vec<Message>,
    /// The status code of the message. 2xx is Okay, 4xx is a client error, 5xx is a server error.
    status_code: u16,
    /// Explain status code reason.
    status_message: String,
    /// Usage statistics for the message.
    usage: Usage,
}

#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum State {
    Start,
    #[default]
    Query,
    RunningAgent,
    AgentDone,
    Coding,
    CodeResult,
    CallingTool,
    ToolResult,
    Generating,
    Answering,
    Thinking,
    Planning,
    Reviewing,
    Understanding,
    Retriving,
    Grounding,
}

/// Tracks token usage for a chat completion request and response.
#[skip_serializing_none]
#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Usage {
    /// Number of tokens in the prompt
    prompt_tokens: Option<u64>,
    /// Number of tokens used during generation
    generated_tokens: Option<u64>,
    /// Total number of tokens used in the request (prompt + generation)
    total_tokens: Option<u64>,
}

#[skip_serializing_none]
#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct UserInfo {
    /// The user information.
    pub user: PublicUser,
    /// The list of users active sessions.
    pub sessions: Option<Vec<PublicSessionOutput>>,
    /// The list of models available to the user.
    pub available_models: Option<Vec<ModelInfoOutput>>,
}

/// User type
#[derive(Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
enum UserType {
    Ui,
    #[default]
    User,
    Admin,
    System,
    Service,
}

#[cfg(test)]
mod tests {
    use std::fmt::Debug;

    use serde::{Deserialize, Serialize};

    use super::*;

    #[test]
    fn serde_ok() {
        #[track_caller]
        fn test<T: Debug + PartialEq + Serialize + for<'a> Deserialize<'a>>(value: T, data: &str) {
            assert_eq!(serde_json::to_string(&value).unwrap(), data);
            assert_eq!(serde_json::from_str::<T>(data).unwrap(), value);
        }
        test(Message::default(), r#"{"message_type":"query"}"#);
        test(
            Message { message_type: MessageType::Result, ..Default::default() },
            r#"{"message_type":"result"}"#,
        );
        test(
            Message { content: Some(None), ..Default::default() },
            r#"{"message_type":"query","content":null}"#,
        );
        test(
            Message { content: Some(Some("foo".to_string())), ..Default::default() },
            r#"{"message_type":"query","content":"foo"}"#,
        );
        test(
            OpResult { data: Some(None), ..Default::default() },
            r#"{"ok":false,"status_code":0,"data":null}"#,
        );
        test(
            OpResult { data: Some(Some([].into())), ..Default::default() },
            r#"{"ok":false,"status_code":0,"data":{}}"#,
        );
        test(
            OpResult {
                data: Some(Some([("foo".into(), Value::Null)].into())),
                ..Default::default()
            },
            r#"{"ok":false,"status_code":0,"data":{"foo":null}}"#,
        );
    }
}
